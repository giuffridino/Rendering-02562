<!DOCTYPE html>
<html>
<head>
    <title>Final Project</title>
    <script type="text/javascript" src="final-project.js"></script>
    <script type="text/javascript" src="common/MV.js"></script>
    <script type="text/javascript" src="common/OBJParser_interleaved.js"></script>
    <script type="text/javascript" src="common/BspTree_interleaved.js"></script>
    <script type="text/javascript" src="common/Aabb.js"></script>
</head>
<body>
    <canvas id="webgpu-canvas" width="800" height="450">
        Please use a browser that supports HTML5 canvas.
    </canvas>
    <script id="wgsl" type="x-shader">
        //Define Uniforms struct
        struct Uniforms
        {
            aspect : f32,
            cam_constant : f32,
        };

        struct Uniforms_UI
        {
            height : u32,
            width : u32,
            frame : u32,
        };

        struct Aabb
        {
            min: vec3f,
            max: vec3f,
        };

        struct Attribs
        {
            vPositions: vec3f,
            vNormals: vec3f,
        };

        struct ColorAttribs
        {
            color: vec4f,
            emission: vec4f,
        };
        
        const MAX_LEVEL = 20u;
        const BSP_LEAF = 3u;
        var<private> branch_node: array<vec2u, MAX_LEVEL>;
        var<private> branch_ray: array<vec2f, MAX_LEVEL>;

        @group(0) @binding(0) var<uniform> uniforms : Uniforms;
        @group(0) @binding(1) var<uniform> uniforms_ui : Uniforms_UI;
        @group(0) @binding(2) var<uniform> aabb : Aabb;
        @group(0) @binding(3) var<storage> attribs : array<Attribs>;
        @group(0) @binding(4) var<storage> meshFaces : array<vec4u>;
        @group(0) @binding(5) var<storage> materialColorEmission : array<ColorAttribs>;
        @group(0) @binding(6) var<storage> lightIndices : array<u32>;
        @group(0) @binding(7) var<storage> treeIds : array<u32>;
        @group(0) @binding(8) var<storage> bspTree : array<vec4u>;
        @group(0) @binding(9) var<storage> bspPlanes : array<f32>;
        @group(0) @binding(10) var<storage> jitter : array<vec2f>;
        @group(0) @binding(11) var renderTexture : texture_2d<f32>;
        
        // Define VSOut struct
        struct VSOut
        {
            @builtin(position) position : vec4f,
            @location(0) coords : vec2f,
        }

        //Define Light struct
        struct Light
        {
            //L_i: f32,
            L_i : vec3f,
            w_i: vec3f,
            dist: f32,
        }

        // Define pi as a constant
        const PI: f32 = 3.14159265359;

        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut
        {
            const pos = array<vec2f, 4>(vec2f(-1.0, 1.0), vec2f(-1.0, -1.0), vec2f(1.0, 1.0), vec2f(1.0, -1.0));
            var vsOut : VSOut;
            vsOut.position = vec4f(pos[VertexIndex], 0.0, 1.0);
            vsOut.coords = pos[VertexIndex];
            return vsOut;
        }
        // Define Ray struct
        struct Ray
        {
            origin : vec3f,
            direction : vec3f,
            t_min : f32,
            t_max : f32,
        }

        //Define HitInfo struct
        struct HitInfo
        {
            has_hit : bool,
            dist : f32,
            position : vec3f,
            normal : vec3f,
            color : vec3f,
            depth : u32,
            shader : u32,
            ior1_over_ior2: f32,
            cos_sq_t: f32,
            emission: vec3f,
            emit: bool,
            rgbFactor: vec3f,
            sigma_t: vec3f,
            inside: bool,
        };

        struct Onb
        {
            tangent: vec3f,
            binormal: vec3f,
            normal: vec3f,
        };
        

        fn get_camera_ray(uv : vec2f) -> Ray
        {
            var p = vec3f(277.0, 275.0, 0.0);
            var up_vec = vec3f(0.0, 1.0, 0.0);
            var r : Ray;
            r.origin = vec3f(277.0, 275.0, -570.0);
            var v = normalize(p - r.origin);
            var b1 = normalize(cross(v, up_vec));
            var b2 = cross(b1, v);
            var q = b1 * uv.x + b2 * uv.y + v * uniforms.cam_constant;
            r.direction = normalize(q); 
            r.t_min = 0.0;
            r.t_max = 1.0e32;
            return r;
        }

        fn intersect_min_max(r: ptr<function, Ray>) -> bool
        { 
            let p1 = (aabb.min - (*r).origin) / (*r).direction;
            let p2 = (aabb.max - (*r).origin) / (*r).direction;
            let pmin = min(p1, p2);
            let pmax = max(p1, p2);
            let tmin = max(pmin.x, max(pmin.y, pmin.z));
            let tmax = min(pmax.x, min(pmax.y, pmax.z));
            if (tmin > tmax || tmin > (*r).t_max || tmax < (*r).t_min)
            {
                return false;
            }
            (*r).t_min = max(tmin - 1.0e-2f, (*r).t_min);
            (*r).t_max = min(tmax + 1.0e-2f, (*r).t_max);
            return true;
        }

        fn intersect_trimesh(r: ptr<function, Ray>, hit:ptr<function, HitInfo>, idx:ptr<function, Idx>) -> bool
        {
            var branch_lvl = 0u;
            var near_node = 0u;
            var far_node = 0u;
            var t = 0.0f;
            var node = 0u;
            for (var i = 0u; i <= MAX_LEVEL; i++)
            {
                let tree_node = bspTree[node];
                let node_axis_leaf = tree_node.x&3u;
                if (node_axis_leaf == BSP_LEAF)
                {
                    let node_count = tree_node.x>>2u;
                    let node_id = tree_node.y;
                    var found = false;
                    for (var j = 0u; j < node_count; j++)
                    {
                        let obj_idx = treeIds[node_id + j];
                        if(intersect_triangle(*r, hit, obj_idx))
                        {
                            (*r).t_max = (*hit).dist;
                            (*idx).i = obj_idx;
                            found = true;
                        }
                    }
                    if (found) { return true; }
                    else if (branch_lvl == 0u) { return false; }
                    else
                    {
                        branch_lvl--;
                        i = branch_node[branch_lvl].x;
                        node = branch_node[branch_lvl].y;
                        (*r).t_min = branch_ray[branch_lvl].x;
                        (*r).t_max = branch_ray[branch_lvl].y;
                        continue;
                    }
                }
                let axis_direction = (*r).direction[node_axis_leaf];
                let axis_origin = (*r).origin[node_axis_leaf];
                if (axis_direction >= 0.0f)
                {
                    near_node = tree_node.z;
                    far_node = tree_node.w;
                }
                else
                {
                    near_node = tree_node.w;
                    far_node = tree_node.z;
                }
                let node_plane = bspPlanes[node];
                let denom = select(axis_direction, 1.0e-8f, abs(axis_direction) < 1.0e-8f);
                t = (node_plane - axis_origin) / denom;
                if (t > (*r).t_max) { node = near_node; }
                else if(t < (*r).t_min) { node = far_node; }
                else
                {
                    branch_node[branch_lvl].x = i;
                    branch_node[branch_lvl].y = far_node;
                    branch_ray[branch_lvl].x = t;
                    branch_ray[branch_lvl].y = (*r).t_max;
                    branch_lvl++;
                    (*r).t_max = t;
                    node = near_node;
                }
            }   

            return false;
        }

        fn intersect_triangle(r: Ray, hit: ptr<function, HitInfo>, f_index: u32) -> bool
        {
            var f = meshFaces[f_index];
            var v0 = attribs[f.x].vPositions;
            var v1 = attribs[f.y].vPositions;
            var v2 = attribs[f.z].vPositions;
            var n0 = attribs[f.x].vNormals;
            var n1 = attribs[f.y].vNormals;
            var n2 = attribs[f.z].vNormals;

            var e0 = v1 - v0;
            var e1 = v2 - v0;
            var normal = cross(e0, e1);
            if((abs(dot(r.direction, normal))) < 1e-8)
            {
                return false;
            }
            var beta = dot(cross(v0 - r.origin, r.direction), e1) / dot(r.direction, normal);
            var gamma = - dot(cross(v0 - r.origin, r.direction), e0) / dot(r.direction, normal);
            if(beta >= 0 && gamma >= 0 && beta + gamma <= 1)
            {
                var t_prime = dot(v0 - r.origin, normal) / dot(r.direction, normal);
                if(t_prime > r.t_min && t_prime < r.t_max)
                {
                    (*hit).has_hit = true;
                    (*hit).dist = t_prime;
                    (*hit).position = r.origin + t_prime * r.direction;
                    (*hit).normal = normalize((1 - beta - gamma) * n0 + beta * n1 + gamma * n2);
                    return true;
                }
            }
            return false;
        }

        struct Idx
        {
            i: u32,
        };

        fn intersect_sphere(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, radius: f32) -> bool
        {
            var b_half = dot((r.origin - center), r.direction);
            var c = dot(r.origin - center, r.origin - center) - pow(radius, 2);
            var temp = pow(b_half, 2) - c;
            if(temp < 0.0f)
            {
                return false;
            }
            var t1 = -b_half - sqrt(pow(b_half, 2) - c);
            if(t1 > r.t_min && t1 < r.t_max)
            {
                (*hit).has_hit = true;
                (*hit).dist = t1;
                (*hit).position = r.origin + t1 * r.direction;
                (*hit).normal = normalize((*hit).position - center);
                return true;
            }
            var t2 = -b_half + sqrt(pow(b_half, 2) - c);
            if(t2 > r.t_min && t2 < r.t_max)
            {
                (*hit).has_hit = true;
                (*hit).dist = t2;
                (*hit).position = r.origin + t2 * r.direction;
                (*hit).normal = normalize((*hit).position - center);
                return true;
            }
            return false;
        }

        fn isZero(a: f32) -> bool {
            return abs(a) < 0.00001;
        }
        
        fn solveQuadraticEquation(a: f32, b: f32, c: f32, roots: ptr<function, array<f32, 2>>) -> i32 {
            if (isZero(a)) {
                if (isZero(b)) {
                    return 0;
                } else {
                    (*roots)[0] = -c / b;
                    return 1;
                }
            } else {
                let radicand: f32 = b*b - 4.0*a*c;
                if (isZero(radicand)) {
                    (*roots)[0] = -b / (2.0 * a);
                    return 1;
                } else {
                    let r: f32 = sqrt(radicand);
                    let d: f32 = 2.0 * a;
        
                    (*roots)[0] = (-b + r) / d;
                    (*roots)[1] = (-b - r) / d;
                    return 2;
                }
            }
        }
        
        fn cbrt(a: f32, n: i32) -> f32 {
            let TWOPI: f32 = 2.0 * 3.141592653589793238462643383279502884;
            let rho: f32 = pow(abs(a), 1.0/3.0);
            let theta: f32 = ((TWOPI * f32(n)) + atan(a)) / 3.0;
            return rho * cos(theta);
        }
        
        fn solveCubicEquation(a: f32, b: f32, c: f32, d: f32, roots: ptr<function, array<f32, 3>>) -> i32 {
            if (isZero(a)) {
                var quadraticRoots: array<f32, 2> = array<f32, 2>(0.0, 0.0);
                let numRoots: i32 = solveQuadraticEquation(b, c, d, &quadraticRoots);
                for (var i = 0; i < numRoots; i = i + 1) {
                    (*roots)[i] = quadraticRoots[i];
                }
                return numRoots;
            }
        
            let t_b = b/a;
            let t_c = c/a;
            let t_d = d/a;
        
            var S: f32 = t_b/3.0;
            var D: f32 = t_c/3.0 - S*S;
            var E: f32 = S*S*S + (t_d - S*t_c)/2.0;
            var Froot: f32 = sqrt(E*E + D*D*D);
            var F: f32 = -Froot - E;
        
            if (isZero(F)) {
                F = Froot - E;
            }
        
            for (var i = 0; i < 3; i = i + 1) {
                let G: f32 = cbrt(F, i);
                (*roots)[i] = G - D/G - S;
            }
        
            return 3;
        }
        
        fn solveQuarticEquation(a: f32, b: f32, c: f32, d: f32, e: f32, roots: ptr<function, array<f32, 4>>) -> i32 {
            if (isZero(a)) {
                var cubicRoots: array<f32, 3> = array<f32, 3>(0.0, 0.0, 0.0);
                let numRoots: i32 = solveCubicEquation(b, c, d, e, &cubicRoots);
                for (var i = 0; i < numRoots; i = i + 1) {
                    (*roots)[i] = cubicRoots[i];
                }
                return numRoots;
            }
        
            let t_b: f32 = b/a;
            let t_c: f32 = c/a;
            let t_d: f32 = d/a;
            let t_e: f32 = e/a;
        
            let b2: f32 = t_b * t_b;
            let b3: f32 = t_b * b2;
            let b4: f32 = b2 * b2;
        
            let alpha: f32 = (-3.0/8.0)*b2 + t_c;
            let beta: f32  = b3/8.0 - t_b*t_c/2.0 + t_d;
            let gamma: f32 = (-3.0/256.0)*b4 + b2*t_c/16.0 - t_b*t_d/4.0 + t_e;
        
            let alpha2: f32 = alpha * alpha;
            let t: f32 = -t_b / 4.0;
        
            if (isZero(beta)) {
                let rad: f32 = sqrt(alpha2 - 4.0*gamma);
                let r1: f32 = sqrt((-alpha + rad) / 2.0);
                let r2: f32 = sqrt((-alpha - rad) / 2.0);
                
                var rootValues: array<f32, 4> = array<f32, 4>(t + r1, t - r1, t + r2, t - r2);
                for (var i = 0; i < 4; i = i + 1) {
                    for (var j = i + 1; j < 4; j = j + 1) {
                        if (rootValues[j] < rootValues[i]) {
                            var temp: f32 = rootValues[i];
                            rootValues[i] = rootValues[j];
                            rootValues[j] = temp;
                        }
                    }
                }
                (*roots)[0] = rootValues[0];
                (*roots)[1] = rootValues[1];
                (*roots)[2] = rootValues[2];
                (*roots)[3] = rootValues[3];
                //(*roots)[1] = t - r1;
                //(*roots)[2] = t + r1;
                //(*roots)[3] = t + r2;
                //(*roots)[0] = t - r2;
                return 4;
            } else {
                let alpha3: f32 = alpha * alpha2;
                let P: f32 = -(alpha2/12.0 + gamma);
                let Q: f32 = -alpha3/108.0 + alpha*gamma/3.0 - beta*beta/8.0;
                let R: f32 = -Q/2.0 + sqrt(Q*Q/4.0 + P*P*P/27.0);
                let U: f32 = cbrt(R, 0);
                var y: f32 = (-5.0/6.0)*alpha + U;
                if (isZero(U)) {
                    y -= cbrt(Q,0);
                } else {
                    y -= P/(3.0 * U);
                }
                let W: f32 = sqrt(alpha + 2.0*y);
        
                let r1: f32 = sqrt(-(3.0*alpha + 2.0*y + 2.0*beta/W));
                let r2: f32 = sqrt(-(3.0*alpha + 2.0*y - 2.0*beta/W));
                
                var rootValues: array<f32, 4> = array<f32, 4>(t + (W - r1)/2.0, t + (W + r1)/2.0, t + (-W - r2)/2.0, t + (-W + r2)/2.0);
                for (var i = 0; i < 4; i = i + 1) {
                    for (var j = i + 1; j < 4; j = j + 1) {
                        if (rootValues[j] < rootValues[i]) {
                            var temp: f32 = rootValues[i];
                            rootValues[i] = rootValues[j];
                            rootValues[j] = temp;
                        }
                    }
                }
                (*roots)[0] = rootValues[0];
                (*roots)[1] = rootValues[1];
                (*roots)[2] = rootValues[2];
                (*roots)[3] = rootValues[3];

                //(*roots)[2] = t + ( W - r1)/2.0;
                //(*roots)[3] = t + ( W + r1)/2.0;
                //(*roots)[0] = t + (-W - r2)/2.0;
                //(*roots)[1] = t + (-W + r2)/2.0;
                return 4;
            }
        }
        
        fn intersect_torus2(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, big_radius: f32, small_radius: f32) -> bool
        {
            var RoC = r.origin - center;
            var T = 4.0 * big_radius * big_radius;
            var G = T * (r.direction.x * r.direction.x + r.direction.y * r.direction.y);
            var H = 2.0 * T * (RoC.x * r.direction.x + RoC.y * r.direction.y);
            var I = T * (RoC.x * RoC.x + RoC.y * RoC.y);
            var J = dot(r.direction, r.direction);
            var K = 2.0 * dot(RoC, r.direction);
            var L = dot(r.direction, r.direction) + big_radius * big_radius + small_radius * small_radius;

            var quarticRoots: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
            var numRealRoots = solveQuarticEquation(J*J, 2.0*J*K, 2.0*J*L + K*K - G, 2.0*K*L - H, L*L - I, &quarticRoots);
            var numPositiveRoots = 0;
            for (var i = 0; i < numRealRoots; i = i + 1) {
                if (quarticRoots[i] > 1.0e-4)
                {
                    quarticRoots[numPositiveRoots] = quarticRoots[i];
                    numPositiveRoots += 1;
                }
            }
            for (var i = 0; i < numPositiveRoots; i = i + 1) 
            {
                if (quarticRoots[i] > r.t_min && quarticRoots[i] < r.t_max)
                {
                    (*hit).has_hit = true;
                    (*hit).dist = quarticRoots[i];
                    (*hit).position = r.origin + quarticRoots[i] * r.direction;
                    var temp_a = 1.0 - (big_radius / sqrt(pow((*hit).position.x - center.x, 2) + pow((*hit).position.y - center.y, 2)));
                    var nx = temp_a * ((*hit).position.x - center.x);
                    var ny = temp_a * ((*hit).position.y - center.y);
                    var nz = (*hit).position.z - center.z;
                    var normal_length = sqrt(nx * nx + ny * ny + nz * nz);

                    (*hit).normal = normalize(vec3f(nx / normal_length, ny / normal_length, nz / normal_length));
                    //(*hit).normal = normalize(vec3f(temp_a * (*hit).position.x - center.x, temp_a * (*hit).position.y - center.y, (*hit).position.z - center.z));
                    return true;
                }
            }
            return false;
        }

        fn intersect_torus3(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, big_radius: f32, small_radius: f32) -> bool
        {
            var a = r.origin.x - center.x;
            var b = r.direction.x;
            var c = r.origin.y - center.y;
            var d = r.direction.y;
            var e = r.origin.z - center.z;
            var f = r.direction.z;
            var A = b*b + d*d + f*f;
            var B = 2.0*(a*b + c*d + e*f);
            var C = a*a + c*c + e*e + big_radius*big_radius - small_radius*small_radius;
            var D = 4.0*big_radius*big_radius*(b*b + d*d);
            var E = 8.0*big_radius*big_radius*(a*b + c*d);
            var F = 4.0*big_radius*big_radius*(a*a + c*c);

            var quarticRoots: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
            var numRealRoots = solveQuarticEquation(A*A, 2.0*A*B, 2.0*A*C + B*B - D, 2.0*B*C - E, C*C - F, &quarticRoots);
            var min_sq_dist = 1e8;
            var opt_root = 0.0;
            var opt_hit_pos = vec3f(0.0);
            for (var i = 0; i < numRealRoots; i = i + 1)
            {
                if(quarticRoots[i] < 0.0){ continue; }
                if (quarticRoots[i] > r.t_min && quarticRoots[i] < r.t_max)
                {
                    (*hit).has_hit = true;
                    var hit_pos = r.origin - center + quarticRoots[i] * r.direction;
                    var diff = hit_pos - r.origin - center;
                    var sq_dist = dot(diff, diff);
                    if(min_sq_dist > sq_dist)
                    {
                        min_sq_dist = sq_dist;
                        opt_root = quarticRoots[i];
                        opt_hit_pos = hit_pos;
                    }
                }
            }
            if((*hit).has_hit)
            {
                (*hit).dist = opt_root;
                (*hit).position = opt_hit_pos;
                (*hit).normal = normalize(opt_hit_pos - normalize(vec3f(opt_hit_pos.xy, 0))*big_radius);
                return true;
            }
            return false;
        }

        fn torIntersect(r: Ray, center: vec3f, big_radius: f32, small_radius: f32) -> f32
        {
            var po = 1.0;
            var Ra2 = big_radius*big_radius;
            var ra2 = small_radius*small_radius;
            var gamma = dot(r.origin - center, r.origin - center);
            var beta = dot(r.origin - center,r.direction);
            var delta = (gamma + Ra2 - ra2)/2.0;
            var k3 = beta;
            var k2 = beta*beta - Ra2*dot(r.direction.xy,r.direction.xy) + delta;
            var k1 = beta*delta - Ra2*dot(r.direction.xy,r.origin.xy - center.xy);
            var k0 = delta*delta - Ra2*dot(r.origin.xy - center.xy,r.origin.xy - center.xy);
            if( abs(k3*(k3*k3-k2)+k1) < 0.01 )
            {
                po = -1.0;
                var tmp=k1; k1=k3; k3=tmp;
                k0 = 1.0/k0;
                k1 = k1*k0;
                k2 = k2*k0;
                k3 = k3*k0;
            }
            var c2 = k2*2.0 - 3.0*k3*k3;
            var c1 = k3*(k3*k3-k2)+k1;
            var c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;
            c2 /= 3.0;
            c1 *= 2.0;
            c0 /= 3.0;
            var Q = c2*c2 + c0;
            var R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;
            var h = R*R - Q*Q*Q;
            if( h>=0.0 )  
            {
                h = sqrt(h);
                var v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root
                var u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root
                var s = vec2f( (v+u)+4.0*c2, (v-u)*sqrt(3.0));
                var y = sqrt(0.5*(length(s)+s.x));
                var x = 0.5*s.y/y;
                var r = 2.0*c1/(x*x+y*y);
                var t1 =  x - r - k3; 
                t1 = select(t1, 2.0/t1, (po<0.0));
                var t2 = -x - r - k3; 
                t2 = select(t2, 2.0/t2, (po<0.0));
                var t = 1e20;
                if( t1>0.0 )
                {
                    t=t1;
                } 
                if( t2>0.0 )
                {
                    t=min(t,t2);
                } 
                return t;
            }
            var sQ = sqrt(Q);
            var w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );
            var d2 = -(w+c2); 
            if( d2<0.0 ) { return -1.0; }
            var d1 = sqrt(d2);
            var h1 = sqrt(w - 2.0*c2 + c1/d1);
            var h2 = sqrt(w - 2.0*c2 - c1/d1);
            var t1 = -d1 - h1 - k3;
            t1 = select(t1, 2.0/t1, (po<0.0));
            var t2 = -d1 + h1 - k3;
            t2 = select(t2, 2.0/t2, (po<0.0));
            var t3 =  d1 - h2 - k3;
            t3 = select(t3, 2.0/t3, (po<0.0));
            var t4 =  d1 + h2 - k3;
            t4 = select(t4, 2.0/t4, (po<0.0));
            var t = 1e20;
            if( t1>0.0 ) { t=t1; }
            if( t2>0.0 ) { t=min(t,t2); }
            if( t3>0.0 ) { t=min(t,t3); }
            if( t4>0.0 ) { t=min(t,t4); }
            return t;
        }

        fn torNormal(pos: vec3f, big_radius: f32, small_radius: f32)->vec3f
        {
            return normalize(pos * (dot(pos, pos) - small_radius*small_radius - big_radius*big_radius*vec3f(1.0, 1.0, -1.0)));
        }

        fn intersect_torus4(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, big_radius: f32, small_radius: f32) -> bool
        {
            var t = torIntersect(r, center, big_radius, small_radius);
            if (t > r.t_min && t < r.t_max)
            {
                (*hit).has_hit = true;
                (*hit).dist = t;
                (*hit).position = r.origin + t * r.direction;
                (*hit).normal = torNormal((*hit).position, big_radius, small_radius);
                return true;
            }
            return false;
        }

        fn roundedBoxIntersect(r: Ray, center: vec3f, size: vec3f, radius: f32) -> f32
        {
            // bounding box
            var rd = r.direction;
            var ro = r.origin - center;
            var m = 1.0/rd;
            var n = m*ro;
            var k = abs(m)*(size+radius);
            var t1 = -n - k;
            var t2 = -n + k;
            var tN = max( max( t1.x, t1.y ), t1.z );
            var tF = min( min( t2.x, t2.y ), t2.z );
            if( tN>tF || tF<0.0) {return -1.0;}
            var t = tN;

            // convert to first octant
            var pos = ro+t*rd;
            var s = sign(pos);
            ro  *= s;
            rd  *= s;
            pos *= s;

            // faces
            pos -= size;
            pos = max( pos.xyz, pos.yzx );
            if( min(min(pos.x,pos.y),pos.z) < 0.0 ) {return t;}

            // some precomputation
            var oc = ro - size;
            var dd = rd*rd;
            var oo = oc*oc;
            var od = oc*rd;
            var ra2 = radius*radius;

            t = 1e20; 

            // corner
            {
            var b = od.x + od.y + od.z;
            var c = oo.x + oo.y + oo.z - ra2;
            var h = b*b - c;
            if( h>0.0 ) {t = -b-sqrt(h);}
            }
            // edge X
            {
            var a = dd.y + dd.z;
            var b = od.y + od.z;
            var c = oo.y + oo.z - ra2;
            var h = b*b - a*c;
            if( h>0.0 )
            {
                h = (-b-sqrt(h))/a;
                if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) {t = h;}
            }
            }
            // edge Y
            {
            var a = dd.z + dd.x;
            var b = od.z + od.x;
            var c = oo.z + oo.x - ra2;
            var h = b*b - a*c;
            if( h>0.0 )
            {
                h = (-b-sqrt(h))/a;
                if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) {t = h;}
            }
            }
            // edge Z
            {
            var a = dd.x + dd.y;
            var b = od.x + od.y;
            var c = oo.x + oo.y - ra2;
            var h = b*b - a*c;
            if( h>0.0 )
            {
                h = (-b-sqrt(h))/a;
                if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) {t = h;}
            }
            }

            if( t>1e19 ) {t=-1.0;}
            
            return t;
        }

        fn roundedBoxNormal(pos: vec3f, size: vec3f, radius: f32)->vec3f
        {
            return sign(pos)*normalize(max(abs(pos) - size, vec3f(0.0)));
        }

        fn intersect_roundedBox(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, size: vec3f, radius: f32) -> bool
        {
            var t = roundedBoxIntersect(r, center, size, radius);
            if (t > r.t_min && t < r.t_max)
            {
                (*hit).has_hit = true;
                (*hit).dist = t;
                (*hit).position = r.origin + t * r.direction;
                (*hit).normal = roundedBoxNormal((*hit).position, size, radius);
                return true;
            }
            return false;
        }

        fn cylinderIntersect(r: Ray, center: vec3f, a: vec3f, b: vec3f, radius: f32) -> vec4f
        {
            var ro = r.origin - center;
            var rd = r.direction;
            var ba = b  - a;
            var oc = ro - a;
            var baba = dot(ba,ba);
            var bard = dot(ba,rd);
            var baoc = dot(ba,oc);
            var k2 = baba - bard*bard;
            var k1 = baba*dot(oc,rd) - baoc*bard;
            var k0 = baba*dot(oc,oc) - baoc*baoc - radius*radius*baba;
            var h = k1*k1 - k2*k0;
            if( h<0.0 ) {return vec4(-1.0);}//no intersection
            h = sqrt(h);
            var t = (-k1-h)/k2;
            // body
            var y = baoc + t*bard;
            if( y>0.0 && y<baba ) {return vec4f( t, (oc+t*rd - ba*y/baba)/radius );}
            // caps
            t = (select(baba, 0.0, y<0.0) - baoc)/bard;
            if( abs(k1+k2*t)<h )
            {
                return vec4( t, ba*sign(y)/sqrt(baba) );
            }
            return vec4(-1.0);//no intersection
        }   

        fn cylinderNormal(pos: vec3f, a: vec3f, b: vec3f, radius: f32)->vec3f
        {
            var pa = pos - a;
            var ba = b - a;
            var baba = dot(ba,ba);
            var paba = dot(pa,ba);
            var h = dot(pa,ba)/baba;
            return (pa - ba*h)/radius;
        }

        fn intersect_cylinder(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, a: vec3f, b: vec3f,radius: f32) -> bool
        {
            var t = cylinderIntersect(r, center, a, b, radius);
            if (t.x > r.t_min && t.x < r.t_max)
            {
                (*hit).has_hit = true;
                (*hit).dist = t.x;
                (*hit).position = t.xyz;
                //(*hit).position = r.origin + t * r.direction;
                (*hit).normal = t.yzw;
                //(*hit).normal = cylinderNormal((*hit).position, a, b, radius);
                return true;
            }
            return false;
        }

        fn intersect_scene(r : ptr<function, Ray>, hit : ptr<function, HitInfo>) -> bool
        {
            var idx : Idx;
            if(intersect_sphere((*r), hit, vec3f(420.0, 90.0, 370.0), 90.0))
            {
                (*r).t_max = (*hit).dist;
                (*hit).color = vec3f(0.0, 0.3, 0.0);
                (*hit).shader = 2;
                if(dot((*hit).normal, (*r).direction) < 0)
                {
                    (*hit).ior1_over_ior2 = 1/1.5;
                }
                else
                {
                    (*hit).ior1_over_ior2 = 1.5;
                    (*hit).normal = -(*hit).normal;
                }
            }
            if(intersect_torus4((*r), hit, vec3f(130.0, 150.0, 250.0), 90, 25.0))
            {
                (*r).t_max = (*hit).dist;
                (*hit).color = vec3f(0.5, 0.5, 1.0);
                (*hit).shader = 2;
                if(dot((*hit).normal, (*r).direction) < 0)
                {
                    (*hit).ior1_over_ior2 = 1/1.5;
                }
                else
                {
                    (*hit).ior1_over_ior2 = 1.5;
                    (*hit).normal = -(*hit).normal;
                }
            }
            //if(intersect_roundedBox((*r), hit, vec3f(130.0, 150.0, 250.0), vec3f(50.0, 50.0, 50.0), 25.0))
            //{
            //    (*r).t_max = (*hit).dist;
            //    (*hit).color = vec3f(0.5, 0.5, 1.0);
            //    (*hit).shader = 1;
            //    if(dot((*hit).normal, (*r).direction) < 0)
            //    {
            //        (*hit).ior1_over_ior2 = 1/1.5;
            //    }
            //    else
            //    {
            //        (*hit).ior1_over_ior2 = 1.5;
            //        (*hit).normal = -(*hit).normal;
            //    }
            //}
            //if(intersect_cylinder((*r), hit, vec3f(50.0, 150.0, 250.0), vec3f(70.0, 70.0, 70.0), vec3f(70.0, -140.0, 70.0), 100.0))
            //{
            //    (*r).t_max = (*hit).dist;
            //    (*hit).color = vec3f(0.5, 0.5, 0.7);
            //    (*hit).shader = 2;
            //    if(dot((*hit).normal, (*r).direction) < 0)
            //    {
            //        (*hit).ior1_over_ior2 = 1/1.5;
            //    }
            //    else
            //    {
            //        (*hit).ior1_over_ior2 = 1.5;
            //        (*hit).normal = -(*hit).normal;
            //    }
            //}
            
            
            //if(intersect_sphere((*r), hit, vec3f(130.0, 90.0, 250.0), 90.0))
            //{
            //    (*r).t_max = (*hit).dist;
            //    (*hit).color = vec3f(0.0, 0.0, 0.0);
            //    (*hit).shader = 4;
            //    (*hit).sigma_t = vec3f(0.4, 0.4, 0.39);
            //    //(*hit).sigma_t = vec3f(1e-1, 1e-1, 1e-2);
            //    (*hit).inside = dot((*hit).normal, (*r).direction) > 0;
            //    if(!(*hit).inside)
            //    {
            //        (*hit).ior1_over_ior2 = 1/1.5;
            //    }
            //    else
            //    {
            //        (*hit).ior1_over_ior2 = 1.5;
            //        (*hit).normal = -(*hit).normal;
            //    }
            //}
            if(intersect_trimesh(r, hit, &idx)) 
            {
                var face = meshFaces[idx.i].w;
                (*hit).color = materialColorEmission[face].color.xyz;
                (*hit).emission = materialColorEmission[face].emission.xyz;
                (*hit).shader = 1;
            }
            return (*hit).has_hit;
        }

        fn sample_point_light(pos: vec3f) -> Light
        {
            var light : Light;
            var light_pos = vec3f(0.0, 1.0, 0.0);
            light.L_i = vec3f(PI) / dot(light_pos - pos, light_pos - pos);
            //light.L_i = PI / dot(light_pos - pos, light_pos - pos);
            light.w_i = normalize(light_pos - pos);
            light.dist = length(light_pos - pos);
            return light;
        }

        fn sample_directional_light(pos : vec3f) -> Light
        {
            var dir_light : Light;
            dir_light.L_i = vec3f(PI);
            dir_light.w_i = -normalize(vec3f(-1.0, -1.0, -1.0));
            dir_light.dist = 1.0e8;
            //dir_light.dist = 0.0;
            return dir_light;
        }

        fn calculate_area(v1 : vec3f, v2 : vec3f, v3 : vec3f) -> f32
        {
            var AB = vec3f(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
            var AC = vec3f(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);
            return 0.5 * length(cross(AB, AC));
        }

        fn calculate_normal_area(v1 : vec3f, v2 : vec3f, v3 : vec3f) -> vec3f
        {
            var AB = vec3f(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
            var AC = vec3f(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);
            return 0.5 * cross(AB, AC);
        }

        fn calculate_center(v1 : vec3f, v2 : vec3f, v3 : vec3f) -> vec3f
        {
            var x = (v1.x + v2.x + v3.x) / 3;
            var y = (v1.y + v2.y + v3.y) / 3;
            var z = (v1.z + v2.z + v3.z) / 3;
            return vec3f(x, y, z);
        }

        fn sample_area_light(pos : vec3f, t: ptr<function, u32>) -> Light
        {
            var area_light : Light;
            var L_e = 30.0;

            var n = arrayLength(&lightIndices);
            var idx = i32(rnd(t) * f32(n));
            var lightIndex = lightIndices[idx];
            var f = meshFaces[lightIndex];

            var rand_1 = rnd(t);
            var rand_2 = rnd(t);
            var alpha = 1 - sqrt(rand_1);
            var beta = (1 - rand_2) * sqrt(rand_1);
            var gamma = rand_2 * sqrt(rand_1);

            var light_pos = alpha * attribs[f.x].vPositions + beta * attribs[f.y].vPositions + gamma * attribs[f.z].vPositions;
            var int_normal = normalize(alpha * attribs[f.x].vNormals + beta * attribs[f.y].vNormals + gamma * attribs[f.z].vNormals);
            
            area_light.w_i = (light_pos - pos);
            area_light.dist = length(area_light.w_i);

            area_light.w_i = normalize(area_light.w_i);

            var r = length(light_pos - pos);
            //var n_area = calculate_normal_area(attribs[f.x].vPositions, attribs[f.y].vPositions, attribs[f.z].vPositions);
            var area = calculate_area(attribs[f.x].vPositions, attribs[f.y].vPositions, attribs[f.z].vPositions);
            area_light.L_i = materialColorEmission[f.w].emission.xyz * max(dot(int_normal, -area_light.w_i), 0) * f32(n) * area;
            area_light.L_i /= pow(r, 2);
            
            return area_light;
        }

        fn rotate_to_normal(normal: vec3f, v: vec3f) -> vec3f
        {
            let signbit = sign(normal.z + 1.0e-16f);
            let a = -1.0f/(1.0f + abs(normal.z));
            let b = normal.x*normal.y*a;
            return vec3f(1.0f + normal.x*normal.x*a, b, -signbit*normal.x)*v.x
                + vec3f(signbit*b, signbit*(1.0f + normal.y*normal.y*a), -normal.y)*v.y
                + normal*v.z;
        }

        fn spherical_direction(sin_theta: f32, cos_theta: f32, phi: f32) -> vec3f
        {
            let sin_phi = sin(phi);
            let cos_phi = cos(phi);
            return vec3f(sin_theta*cos_phi, sin_theta*sin_phi, cos_theta);
        }

        fn lambertian(r: ptr<function,Ray>, hit: ptr<function, HitInfo>, t: ptr<function, u32>) -> vec3f
        {
            //var light : Light = sample_point_light((*hit).position);
            //var light : Light = sample_directional_light((*hit).position);

            var light : Light = sample_area_light((*hit).position, t);
            var ro = (*hit).color;
            var L_r = vec3f(0.0); 
            //L_r = (*hit).emission;
            if ((*hit).emit)
            {
                L_r += (*hit).emission;
            }

            var rand_1 = rnd(t);
            var rand_2 = rnd(t);
            var theta = acos(sqrt(1 - rand_1));
            var phi = 2 * PI * rand_2;
            var w_ij = spherical_direction(sin(theta), cos(theta), phi);
            w_ij = rotate_to_normal((*hit).normal, w_ij);

            (*hit).emit = false;
            (*hit).rgbFactor *= ro;
            (*hit).has_hit = false; 
            (*hit).depth = (*hit).depth + 1;
            (*r).origin = (*hit).position;
            (*r).t_min = 1.0e-2;
            (*r).t_max = 1.0e32;
            (*r).direction = w_ij;

            //L_r += ro * max(dot(w_ij, (*hit).normal), 0.0) / PI;

            var shadow_ray = Ray((*hit).position, light.w_i, 1.0e-2, light.dist - 1.0e-2);

            var shadow_hit = HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), vec3f(0.0), 0, 1, 0.0, 0.0, vec3f(0.0), false, vec3f(1.0), vec3f(0.0), false);
            if(!intersect_scene(&shadow_ray, &shadow_hit))
            {
                L_r += ro * light.L_i * max(dot(light.w_i, (*hit).normal), 0.0) / PI;
            }
            return L_r;
        }

        fn reflection_shader(r: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> vec3f
        {
            (*hit).has_hit = false; 
            (*hit).depth = (*hit).depth + 1;
            (*hit).emit = true;
            (*r).origin = (*hit).position;
            (*r).t_min = 1.0e-2;
            (*r).t_max = 1.0e32;
            (*r).direction = reflect((*r).direction, (*hit).normal);
            return vec3f(0.0);
        }

        fn refraction_shader(r: ptr<function, Ray>, hit: ptr<function, HitInfo>) -> vec3f
        {
            var dot_prod = dot(-(*r).direction, (*hit).normal);
            (*hit).cos_sq_t = 1 - pow((*hit).ior1_over_ior2, 2) * (1 - pow(dot_prod, 2));
            if((*hit).cos_sq_t < 0)
            {
                reflection_shader(r, hit);
            }
            else
            {
                (*r).direction = (*hit).ior1_over_ior2 * (dot_prod * (*hit).normal + (*r).direction) - (*hit).normal * sqrt((*hit).cos_sq_t);
                (*hit).has_hit = false; 
                (*hit).depth = (*hit).depth + 1;
                (*r).origin = (*hit).position;
                (*r).t_min = 1.0e-2;
                (*r).t_max = 1.0e32;
            }
            return vec3f(0.0);
        }

        fn fresnel_R(cos_i: f32, cos_t: f32, ior1_over_ior2: f32) -> f32
        {
            var r1 = (ior1_over_ior2 * cos_i - cos_t) / (ior1_over_ior2 * cos_i + cos_t);
            var r2 = (cos_i - ior1_over_ior2 * cos_t) / (cos_i + ior1_over_ior2 * cos_t);
            
            return (abs(pow(r1, 2)) + abs(pow(r2, 2))) / 2;
        }

        fn transparent_shader(r: ptr<function, Ray>, hit: ptr<function, HitInfo>, t: ptr<function, u32>) -> vec3f
        {
            var dot_prod = dot(-(*r).direction, (*hit).normal);
            if((*hit).inside)
            {
                var beam_tr = exp(-(*hit).sigma_t * (*hit).dist);
                var beam_prob = (beam_tr[0] + beam_tr[1] + beam_tr[2]) / 3;
                (*hit).has_hit = select(true, false, rnd(t) < beam_prob);
                (*hit).rgbFactor *= beam_tr / beam_prob;
            }
            (*hit).cos_sq_t = 1 - pow((*hit).ior1_over_ior2, 2) * (1 - pow(dot_prod, 2));
            var R = select(fresnel_R(dot_prod, sqrt((*hit).cos_sq_t), (*hit).ior1_over_ior2),1.0, (*hit).cos_sq_t < 0);
            var refracted_w = (*hit).ior1_over_ior2 * (dot_prod * (*hit).normal + (*r).direction) - (*hit).normal * sqrt((*hit).cos_sq_t);
            (*r).direction = select(refracted_w, reflect((*r).direction, (*hit).normal), rnd(t) < R);
            (*hit).has_hit = false; 
            (*hit).depth = (*hit).depth + 1;
            (*hit).emit = true;
            (*r).origin = (*hit).position;
            (*r).t_min = 1.0e-2;
            (*r).t_max = 1.0e32;

            return vec3f(0.0);
        }

        fn shade(r: ptr<function, Ray>, hit: ptr<function, HitInfo>, t: ptr<function, u32>) -> vec3f
        {
            switch (*hit).shader
            {
                case 0 {
                    return (*hit).color;
                }
                case 1{
                    return lambertian(r, hit, t);
                }
                case 2{
                    return reflection_shader(r, hit);
                }
                case 3{
                    return refraction_shader(r, hit);
                }
                case 4{
                    return transparent_shader(r, hit, t);
                }
                case default {return (*hit).color;}
            }
        }

        fn tea(v0: u32, v1:u32) -> u32
        {
            var temp0 = v0;
            var temp1 = v1;
            const N = 16u;
            var s0 = 0u;
            for(var n = 0u; n < N; n++)
            {
                s0 += 0x9e3779b9;
                temp0 = temp0 + (((temp1<<4)+0xa341316c)^(temp1+s0)^((temp1>>5)+0xc8013ea4));
                temp1 = temp1 + (((temp0<<4)+0xad90777d)^(temp0+s0)^((temp0>>5)+0x7e95761e));
            }
            return temp0;
        }

        fn mcg31(prev: ptr<function, u32>) -> u32
        {
            const LCG_A = 1977654935u;
            *prev = (LCG_A * (*prev)) & 0x7FFFFFFE;
            return *prev;
        }
        fn rnd(prev: ptr<function, u32>) -> f32
        {
            return f32(mcg31(prev)) / f32(0x80000000);
        }

        struct FSOut
        {
            @location(0) frame: vec4f,
            @location(1) accum: vec4f,
        };

        @fragment
        fn main_fs(@builtin(position) fragcoord: vec4f, @location(0) coords: vec2f) -> FSOut
        {
            var factor = vec3f(1.0);

            let resolution = textureDimensions(renderTexture);
            let launch_idx = u32(fragcoord.y)*resolution.x + u32(fragcoord.x);
            var t = tea(launch_idx, uniforms_ui.frame);
            let jitter = vec2f(rnd(&t), rnd(&t))/f32(resolution.y);

            const bgcolor = vec4f(1.0, 0.5843, 0.9294, 1.0);
            //const bgcolor = vec4f(0.0, 0.0, 0.0, 1.0);
            const max_depth = 30;
            var result = vec3f(0.0);
            var final_result = vec4f(0.0);
            var uv = vec2f(jitter.x + coords.x*uniforms.aspect*0.5, jitter.y + coords.y*0.5);
            var r = get_camera_ray(uv);
            var hit = HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), vec3f(0.0), 0, 1, 0.0, 0.0, vec3f(0.0), true, vec3f(1.0), vec3f(0.0), false);
            for(var i = 0; i < max_depth; i++)
            {
                if (!intersect_min_max(&r)) { result += factor* bgcolor.rgb; break; }
                if(intersect_scene(&r, &hit)) 
                { 
                    result += shade(&r, &hit, &t) * factor; 
                    factor = hit.rgbFactor;

                }
                else { result += factor * bgcolor.rgb; break; }
                if(hit.has_hit) { break; }
            }

            // Progressive update of image
            let curr_sum = textureLoad(renderTexture, vec2u(fragcoord.xy), 0).rgb*f32(uniforms_ui.frame);
            let accum_color = (result + curr_sum)/f32(uniforms_ui.frame + 1u);
            var fsOut: FSOut;
            const gamma = 1.0;
            fsOut.frame = vec4f(pow(accum_color, vec3f(1.0/gamma)), 1.0);
            fsOut.accum = vec4f(accum_color, 1.0);
            return fsOut;
        }
    </script>
    <button id = "Progressive"> Start/Stop Progressive Rendering</button>
</body>
</html> 